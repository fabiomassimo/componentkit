(window.webpackJsonp=window.webpackJsonp||[]).push([[37],{103:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",function(){return p}),t.d(n,"rightToc",function(){return c}),t.d(n,"default",function(){return d});t(0);var a=t(125),o=t(126),r=t.n(o);function i(){return(i=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var a in t)Object.prototype.hasOwnProperty.call(t,a)&&(e[a]=t[a])}return e}).apply(this,arguments)}function s(e,n){if(null==e)return{};var t,a,o=function(e,n){if(null==e)return{};var t,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var p={title:"Responder Chain"},c=[],l={rightToc:c},b="wrapper";function d(e){var n=e.components,t=s(e,["components"]);return Object(a.b)(b,i({},l,t,{components:n,mdxType:"MDXLayout"}),Object(a.b)("p",null,"ComponentKit has a responder chain that is similar to the ",Object(a.b)("a",i({parentName:"p"},{href:"https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/event_delivery_responder_chain/event_delivery_responder_chain.html"}),"responder chain on iOS"),". The ComponentKit responder chain is separate from ",Object(a.b)("inlineCode",{parentName:"p"},"UIView"),"'s responder chain, so you must manually bridge over to the component responder chain if desired."),Object(a.b)("img",{src:r()("assets/responder-chain.png"),alt:"Responder Chain",width:"618",height:"443"}),Object(a.b)("ol",null,Object(a.b)("li",{parentName:"ol"},"The next responder of a component is its ",Object(a.b)("a",i({parentName:"li"},{href:"./component-controllers"}),"controller"),", if it has one."),Object(a.b)("li",{parentName:"ol"},"The next responder of a component's controller is its component's parent component."),Object(a.b)("li",{parentName:"ol"},"If a component doesn't have a controller, its next responder is its parent component."),Object(a.b)("li",{parentName:"ol"},"The next responder of the root component is the view it is attached to."),Object(a.b)("li",{parentName:"ol"},"As normal, a view's next responder is its superview."),Object(a.b)("li",{parentName:"ol"},"Eventually, this will reach the same root view as the component hierarchy."),Object(a.b)("li",{parentName:"ol"},"It's up to you to manually bridge from the view responder chain into the component responder chain if desired by using ",Object(a.b)("inlineCode",{parentName:"li"},"CKComponentActionSend")," or one of the helpers described below.")),Object(a.b)("p",null,"Note that a component is not a subclass of ",Object(a.b)("inlineCode",{parentName:"p"},"UIResponder")," and it cannot become the first responder. It does implement both ",Object(a.b)("inlineCode",{parentName:"p"},"nextResponder")," and ",Object(a.b)("inlineCode",{parentName:"p"},"targetForAction:withSender:"),", however."),Object(a.b)("h1",null,Object(a.b)("a",i({parentName:"h1"},{"aria-hidden":!0,className:"anchor",id:"tap-handling"})),Object(a.b)("a",i({parentName:"h1"},{"aria-hidden":!0,className:"hash-link",href:"#tap-handling"}),"#"),"Tap Handling"),Object(a.b)("p",null,"The easiest way to handle taps on ",Object(a.b)("inlineCode",{parentName:"p"},"UIControl")," views is to use ",Object(a.b)("inlineCode",{parentName:"p"},"CKComponentActionAttribute"),". It returns a component attribute that triggers a ",Object(a.b)("a",i({parentName:"p"},{href:"./actions"}),"component action")," when any given ",Object(a.b)("inlineCode",{parentName:"p"},"UIControlEvent")," occurs. For example:"),Object(a.b)("pre",null,Object(a.b)("code",i({parentName:"pre"},{className:"language-objectivec"}),"@implementation SomeComponent\n\n+ (instancetype)new\n{\n  return [self newWithView:{\n    [UIButton class],\n    {CKComponentActionAttribute(@selector(didTapButton))}\n  }];\n}\n\n- (void)didTapButton\n{\n  // Aha! The button has been tapped.\n}\n\n@end\n")),Object(a.b)("h1",null,Object(a.b)("a",i({parentName:"h1"},{"aria-hidden":!0,className:"anchor",id:"gestures"})),Object(a.b)("a",i({parentName:"h1"},{"aria-hidden":!0,className:"hash-link",href:"#gestures"}),"#"),"Gestures"),Object(a.b)("p",null,"That works for ",Object(a.b)("inlineCode",{parentName:"p"},"UIControls"),", but what about other views? Fear not, you can use ",Object(a.b)("inlineCode",{parentName:"p"},"CKComponentTapGestureAttribute"),". This allows you to install a tap gesture recognizer on any ",Object(a.b)("inlineCode",{parentName:"p"},"UIView")," and be notified when the tap occurs."),Object(a.b)("pre",null,Object(a.b)("code",i({parentName:"pre"},{className:"language-objectivec"}),"@implementation SomeComponent\n\n+ (instancetype)new\n{\n  return [self newWithView:{\n    [UIView class],\n    {CKComponentTapGestureAttribute(@selector(didTapView))}\n  }];\n}\n\n- (void)didTapView\n{\n  // The view has been tapped.\n}\n\n@end\n")),Object(a.b)("h1",null,Object(a.b)("a",i({parentName:"h1"},{"aria-hidden":!0,className:"anchor",id:"advanced-gestures"})),Object(a.b)("a",i({parentName:"h1"},{"aria-hidden":!0,className:"hash-link",href:"#advanced-gestures"}),"#"),"Advanced Gestures"),Object(a.b)("p",null,"What about advanced gestures like panning, pinching, swiping, and so on?"),Object(a.b)("p",null,'These are more complicated. The way the reactive-update model is implemented in ComponentKit is fairly limited, so the best option is to build an "escape hatch" from the reactive data flow for these at present. Drop down and mutate the underlying views directly as the user performs a gesture.'))}d.isMDXComponent=!0}}]);